{"mappings":"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","sources":["src/main.js"],"sourcesContent":["(function() {\n    const canvas = document.getElementById('gameCanvas');\n    const ctx = canvas.getContext('2d');\n  \n    let gameState = \"start\";\n    let gameOverTimer = 0;\n    const GAME_OVER_DURATION = 5000;\n  \n    let dotX, dotY;\n    let angle = 0;\n    const speed = 1.2;\n    const dotSize = 10;\n  \n    let chasers = [];\n    const INITIAL_CHASER_SIZE = 120;\n    const CHASER_SPEED = 1.1;\n    const REPULSION_STRENGTH = 0.5;\n    const REPULSION_DISTANCE = 150;\n    const SPREAD_TIME = 2000; // Time in ms for initial spreading\n    let spreadStartTime = 0;\n    let lastSplitScore = 0;\n  \n    let collectibles = [];\n    let score = 0;\n  \n    let stars = [];\n    let mudPatches = [];\n    const MUD_AVOIDANCE_DISTANCE = 100;\n    const MUD_AVOIDANCE_STRENGTH = 1.5;\n    let dotControlDisabledUntil = 0;\n  \n    // Add dot color state\n    let dotColor = 'yellow';\n    let dotSlipAmount = 0;\n  \n    // Add constant for new chaser spawn distance\n    const MIN_SPAWN_DISTANCE = 180; // About 3 inches at typical screen DPI\n    let lastSpawnScore = 0; // Track last score we spawned a chaser at\n  \n    // Add health system variables\n    let lives = 3;\n    let dotInvincibleUntil = 0;\n  \n    // Add speed crate properties\n    let speedCrates = [];\n    const SPEED_BOOST_DURATION = 10000; // 10 seconds boost\n    const CRATE_SIZE = 25;\n    let dotSpeedBoostUntil = 0;\n    let chaserSpeedIncrease = 0;\n  \n    // Create (or reuse) a single AudioContext for your game\n    const audioContext = new (window.AudioContext || window.webkitAudioContext)();\n  \n    /**\n     * Starts an upbeat, layered background music loop.\n     * The chord layer (sine oscillators) provides a warm base while the\n     * melody layer (sawtooth oscillator) plays an arpeggio.\n     */\n    function startBackgroundMusic() {\n      const masterGain = audioContext.createGain();\n      masterGain.gain.value = 0.05; // Master volume\n      masterGain.connect(audioContext.destination);\n      \n      // --- Chord layer ---\n      // A subtle, warm chord using sine oscillators (A2, C3, D3)\n      const chordFrequencies = [110, 130.81, 146.83];\n      const chordOscillators = [];\n      chordFrequencies.forEach(freq => {\n        const osc = audioContext.createOscillator();\n        osc.type = 'sine';\n        osc.frequency.value = freq;\n        osc.connect(masterGain);\n        osc.start();\n        chordOscillators.push(osc);\n      });\n\n      // --- Melody layer (arpeggio) ---\n      // An upbeat arpeggio using a sawtooth oscillator for a brighter feel.\n      const melodyOsc = audioContext.createOscillator();\n      melodyOsc.type = 'sawtooth';\n      const melodyGain = audioContext.createGain();\n      melodyGain.gain.value = 0.02; // Lower volume to blend with chords\n      melodyOsc.connect(melodyGain);\n      melodyGain.connect(masterGain);\n      melodyOsc.start();\n\n      // Define an arpeggio array (A3, B3, C4, D4)\n      const arpeggioNotes = [220, 246.94, 261.63, 293.66];\n      let noteIndex = 0;\n      function scheduleNextNote() {\n        melodyOsc.frequency.setValueAtTime(arpeggioNotes[noteIndex], audioContext.currentTime);\n        noteIndex = (noteIndex + 1) % arpeggioNotes.length;\n        setTimeout(scheduleNextNote, 500); // Change note every 500 ms\n      }\n      scheduleNextNote();\n\n      return { chordOscillators, melodyOscillator: melodyOsc, melodyGain };\n    }\n  \n    /**\n     * Plays a short \"slip\" sound.\n     * This function creates a burst of filtered white noise that fades out quickly.\n     */\n    function playSlipSound() {\n      const duration = 0.5;\n      const bufferSize = audioContext.sampleRate * duration;\n      const noiseBuffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);\n      const output = noiseBuffer.getChannelData(0);\n      for (let i = 0; i < bufferSize; i++) {\n        output[i] = Math.random() * 2 - 1;\n      }\n      const noiseSource = audioContext.createBufferSource();\n      noiseSource.buffer = noiseBuffer;\n  \n      const filter = audioContext.createBiquadFilter();\n      filter.type = 'lowpass';\n      filter.frequency.value = 300; // Adjust frequency for a muffled slip sound\n  \n      const gainNode = audioContext.createGain();\n      gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);\n      gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);\n  \n      noiseSource.connect(filter);\n      filter.connect(gainNode);\n      gainNode.connect(audioContext.destination);\n  \n      noiseSource.start();\n      noiseSource.stop(audioContext.currentTime + duration);\n    }\n  \n    function initializeStars() {\n      stars = [];\n      const numStars = 50;\n      for (let i = 0; i < numStars; i++) {\n        stars.push({\n          x: Math.random() * canvas.width,\n          y: Math.random() * canvas.height,\n          radius: Math.random() * 2 + 1\n        });\n      }\n    }\n\n    function initializeGamePositions() {\n      dotX = canvas.width / 2;\n      dotY = canvas.height / 2;\n      chasers = [{\n        x: INITIAL_CHASER_SIZE / 2,\n        y: INITIAL_CHASER_SIZE / 2,\n        size: INITIAL_CHASER_SIZE,\n        speed: CHASER_SPEED\n      }];\n      angle = 0;\n      collectibles = [{\n        x: Math.random() * canvas.width,\n        y: Math.random() * canvas.height,\n        size: 15\n      }];\n      mudPatches = [];\n      lastSplitScore = 0;\n      lives = 3;\n      dotInvincibleUntil = 0;\n      speedCrates = [];\n      dotSpeedBoostUntil = 0;\n      chaserSpeedIncrease = 0;\n    }\n  \n    function startGame() {\n      gameState = \"playing\";\n      startBtn.style.display = \"none\";\n      initializeGamePositions();\n      score = 0;\n      spreadStartTime = Date.now();\n      // Start background music (store oscillators if you later wish to stop them on game over)\n      const bgOscillators = startBackgroundMusic();\n    }\n  \n    const leftBtn = document.getElementById('leftBtn');\n    const rightBtn = document.getElementById('rightBtn');\n    const upBtn = document.getElementById('upBtn');\n    const downBtn = document.getElementById('downBtn');\n    const startBtn = document.getElementById('startBtn');\n  \n    leftBtn.addEventListener('click', () => {\n      if (gameState === \"playing\" && Date.now() >= dotControlDisabledUntil) angle = Math.PI;\n    });\n    rightBtn.addEventListener('click', () => {\n      if (gameState === \"playing\" && Date.now() >= dotControlDisabledUntil) angle = 0;\n    });\n    upBtn.addEventListener('click', () => {\n      if (gameState === \"playing\" && Date.now() >= dotControlDisabledUntil) angle = -Math.PI / 2;\n    });\n    downBtn.addEventListener('click', () => {\n      if (gameState === \"playing\" && Date.now() >= dotControlDisabledUntil) angle = Math.PI / 2;\n    });\n  \n    document.addEventListener('keydown', (event) => {\n      if (gameState === \"start\" && event.code === \"Space\") {\n        startGame();\n      } else if (gameState === \"playing\" && Date.now() >= dotControlDisabledUntil) {\n        switch (event.key) {\n          case 'ArrowLeft': angle = Math.PI; break;\n          case 'ArrowRight': angle = 0; break;\n          case 'ArrowUp': angle = -Math.PI / 2; break;\n          case 'ArrowDown': angle = Math.PI / 2; break;\n        }\n      }\n    });\n  \n    startBtn.addEventListener('click', startGame);\n  \n    function gameLoop() {\n      if (gameState === \"playing\") {\n        updateGame();\n        renderGame();\n      } else if (gameState === \"gameOver\") {\n        renderGameOver();\n        if (Date.now() - gameOverTimer > GAME_OVER_DURATION) {\n          gameState = \"start\";\n          startBtn.style.display = \"block\";\n        }\n      } else if (gameState === \"start\") {\n        renderStartScreen();\n      }\n      requestAnimationFrame(gameLoop);\n    }\n  \n    function updateGame() {\n      // Update dot position with speed effects\n      let currentSpeed = speed;\n      if (Date.now() < dotSpeedBoostUntil) {\n        currentSpeed = 2; // Boosted speed\n        dotColor = 'skyblue';\n      } else if (dotSlipAmount > 0) {\n        currentSpeed = speed * 3; // Mud slip effect\n        dotSlipAmount *= 0.95;\n        if (dotSlipAmount < 0.01) dotSlipAmount = 0;\n      } else if (dotColor !== 'yellow' && Date.now() >= dotControlDisabledUntil) {\n        dotColor = 'yellow';\n      }\n      \n      dotX += currentSpeed * Math.cos(angle);\n      dotY += currentSpeed * Math.sin(angle);\n      wrapAround(\"dot\");\n  \n      // Group decision-making for chasers\n      let keyTarget = null;\n      let speedCrateTarget = null;\n      \n      // Find closest key to dot\n      if (collectibles.length > 0) {\n        let minDist = Infinity;\n        for (let item of collectibles) {\n          const d = distanceBetween(dotX, dotY, item.x, item.y);\n          if (d < minDist) {\n            minDist = d;\n            keyTarget = item;\n          }\n        }\n      }\n      \n      // Find closest speed crate to dot\n      if (speedCrates.length > 0) {\n        let minDist = Infinity;\n        for (let crate of speedCrates) {\n          const d = distanceBetween(dotX, dotY, crate.x, crate.y);\n          if (d < minDist) {\n            minDist = d;\n            speedCrateTarget = crate;\n          }\n        }\n      }\n\n      // Update chasers with roles\n      const spreading = Date.now() - spreadStartTime < SPREAD_TIME;\n      chasers.forEach((chaser, index) => {\n        let repulsionX = 0;\n        let repulsionY = 0;\n        let targetX, targetY;\n\n        if (!spreading) {\n          // Assign roles based on position and index\n          if (keyTarget && index === 0) {\n            // First chaser goes for key\n            targetX = keyTarget.x;\n            targetY = keyTarget.y;\n          } else if (speedCrateTarget && index === 1) {\n            // Second chaser goes for speed crate\n            targetX = speedCrateTarget.x;\n            targetY = speedCrateTarget.y;\n          } else {\n            // Others form circle around dot\n            const formationOffset = 50;\n            const offsetAngle = (index / chasers.length) * (2 * Math.PI);\n            targetX = dotX + formationOffset * Math.cos(offsetAngle);\n            targetY = dotY + formationOffset * Math.sin(offsetAngle);\n          }\n        } else {\n          // Spreading phase logic\n          switch(index % 4) {\n            case 0: targetX = canvas.width * 0.1; targetY = canvas.height * 0.1; break;\n            case 1: targetX = canvas.width * 0.9; targetY = canvas.height * 0.9; break;\n            case 2: targetX = canvas.width * 0.9; targetY = canvas.height * 0.1; break;\n            case 3: targetX = canvas.width * 0.1; targetY = canvas.height * 0.9; break;\n          }\n        }\n\n        // Calculate direction to target\n        let dx = targetX - chaser.x;\n        let dy = targetY - chaser.y;\n\n        // Wrap-around adjustments\n        if (dx > canvas.width / 2) dx -= canvas.width;\n        else if (dx < -canvas.width / 2) dx += canvas.width;\n        if (dy > canvas.height / 2) dy -= canvas.height;\n        else if (dy < -canvas.height / 2) dy += canvas.height;\n\n        const angleToTarget = Math.atan2(dy, dx);\n\n        // Apply repulsion between chasers\n        for (let other of chasers) {\n          if (other === chaser) continue;\n          let rx = chaser.x - other.x;\n          let ry = chaser.y - other.y;\n          if (rx > canvas.width / 2) rx -= canvas.width;\n          else if (rx < -canvas.width / 2) rx += canvas.width;\n          if (ry > canvas.height / 2) ry -= canvas.height;\n          else if (ry < -canvas.height / 2) ry += canvas.height;\n          \n          const distSq = rx * rx + ry * ry;\n          if (distSq < REPULSION_DISTANCE * REPULSION_DISTANCE && distSq > 0) {\n            const dist = Math.sqrt(distSq);\n            const strength = REPULSION_STRENGTH * (1 - dist / REPULSION_DISTANCE);\n            repulsionX += (rx / dist) * strength;\n            repulsionY += (ry / dist) * strength;\n          }\n        }\n\n        // Improved mud avoidance\n        for (let mud of mudPatches) {\n          let rxMud = chaser.x - mud.x;\n          let ryMud = chaser.y - mud.y;\n          if (rxMud > canvas.width / 2) rxMud -= canvas.width;\n          else if (rxMud < -canvas.width / 2) rxMud += canvas.width;\n          if (ryMud > canvas.height / 2) ryMud -= canvas.height;\n          else if (ryMud < -canvas.height / 2) ryMud += canvas.height;\n          \n          const effectiveMudDistance = MUD_AVOIDANCE_DISTANCE + chaser.size / 2;\n          const distSqMud = rxMud * rxMud + ryMud * ryMud;\n          if (distSqMud < effectiveMudDistance * effectiveMudDistance && distSqMud > 0) {\n            const distMud = Math.sqrt(distSqMud);\n            const strengthMud = MUD_AVOIDANCE_STRENGTH * (1 - distMud / effectiveMudDistance);\n            repulsionX += (rxMud / distMud) * strengthMud;\n            repulsionY += (ryMud / distMud) * strengthMud;\n          }\n        }\n\n        // Combine forces and move chaser\n        const finalAngle = Math.atan2(\n          Math.sin(angleToTarget) + repulsionY,\n          Math.cos(angleToTarget) + repulsionX\n        );\n        \n        chaser.x += chaser.speed * Math.cos(finalAngle);\n        chaser.y += chaser.speed * Math.sin(finalAngle);\n        wrapAroundChaser(chaser);\n\n        for (let i = collectibles.length - 1; i >= 0; i--) {\n          const item = collectibles[i];\n          const dxKey = chaser.x - item.x;\n          const dyKey = chaser.y - item.y;\n          const distance = Math.sqrt(dxKey * dxKey + dyKey * dyKey);\n          if (distance < (chaser.size / 2 + item.size / 2)) {\n            collectibles.splice(i, 1);\n          }\n        }\n      });\n  \n      for (let i = collectibles.length - 1; i >= 0; i--) {\n        const item = collectibles[i];\n        const dxKey = dotX - item.x;\n        const dyKey = dotY - item.y;\n        const distance = Math.sqrt(dxKey * dxKey + dyKey * dyKey);\n        if (distance < (dotSize / 2 + item.size / 2)) {\n          collectibles.splice(i, 1);\n          score++;\n          \n          // Check for chaser splitting (every 5 points)\n          if (score > 0 && score % 5 === 0 && score !== lastSplitScore) {\n            let newChasers = [];\n            for (let chaser of chasers) {\n              let dx = dotX - chaser.x;\n              let dy = dotY - chaser.y;\n              let angleToDot = Math.atan2(dy, dx);\n              let perpAngle = angleToDot + Math.PI / 2;\n              let offset = chaser.size;\n              \n              // Calculate speed based on new size\n              let newSize = chaser.size / 2;\n              let newSpeed = Math.min(1.4, CHASER_SPEED * (120 / newSize));\n              \n              newChasers.push({\n                x: chaser.x + offset * Math.cos(perpAngle),\n                y: chaser.y + offset * Math.sin(perpAngle),\n                size: newSize,\n                speed: newSpeed\n              });\n              newChasers.push({\n                x: chaser.x - offset * Math.cos(perpAngle),\n                y: chaser.y - offset * Math.sin(perpAngle),\n                size: newSize,\n                speed: newSpeed\n              });\n            }\n            chasers = newChasers;\n            lastSplitScore = score;\n          }\n\n          // Check for new chaser spawn (every 15 points)\n          if (score > 0 && score % 15 === 0 && score !== lastSpawnScore) {\n            // Try to find a valid spawn position\n            let validSpawn = false;\n            let spawnX, spawnY;\n            let attempts = 0;\n            \n            while (!validSpawn && attempts < 100) {\n              spawnX = Math.random() * canvas.width;\n              spawnY = Math.random() * canvas.height;\n              \n              // Check distance from player\n              let dx = spawnX - dotX;\n              let dy = spawnY - dotY;\n              if (dx > canvas.width / 2) dx -= canvas.width;\n              else if (dx < -canvas.width / 2) dx += canvas.width;\n              if (dy > canvas.height / 2) dy -= canvas.height;\n              else if (dy < -canvas.height / 2) dy += canvas.height;\n              \n              let distance = Math.sqrt(dx * dx + dy * dy);\n              if (distance >= MIN_SPAWN_DISTANCE) {\n                validSpawn = true;\n              }\n              attempts++;\n            }\n            \n            // Add new chaser at full size\n            if (validSpawn) {\n              chasers.push({\n                x: spawnX,\n                y: spawnY,\n                size: INITIAL_CHASER_SIZE,\n                speed: CHASER_SPEED\n              });\n              lastSpawnScore = score;\n            }\n          }\n        }\n      }\n  \n      // Check mud collisions - now also removes speed boost and plays slip sound\n      if (Date.now() >= dotControlDisabledUntil) {\n        for (let mud of mudPatches) {\n          let dxMud = dotX - mud.x;\n          let dyMud = dotY - mud.y;\n          let distance = Math.sqrt(dxMud * dxMud + dyMud * dyMud);\n          if (distance < (dotSize / 2 + mud.size / 2)) {\n            dotControlDisabledUntil = Date.now() + (3000 + mud.size * 20);\n            dotColor = '#8B4513';\n            dotSlipAmount = 1.0;\n            dotSpeedBoostUntil = 0; // Remove speed boost when hitting mud\n            \n            // Play the slip sound effect\n            playSlipSound();\n          }\n        }\n      }\n  \n      // Gradually return dot to yellow only after slip effect is done\n      if (dotColor !== 'yellow' && Date.now() >= dotControlDisabledUntil && dotSlipAmount === 0) {\n        dotColor = 'yellow';\n      }\n  \n      // Check collision between dot and chasers\n      if (checkCollision() && Date.now() > dotInvincibleUntil) {\n        lives--;\n        if (lives <= 0) {\n          gameState = \"gameOver\";\n          gameOverTimer = Date.now();\n        } else {\n          // Reset position and give temporary invincibility\n          dotX = canvas.width / 2;\n          dotY = canvas.height / 2;\n          angle = 0;\n          dotInvincibleUntil = Date.now() + 2000; // 2 seconds of invincibility\n        }\n      }\n\n      // Check collisions with speed crates\n      for (let i = speedCrates.length - 1; i >= 0; i--) {\n        const crate = speedCrates[i];\n        // Check dot collision\n        if (distanceBetween(dotX, dotY, crate.x, crate.y) < (dotSize/2 + CRATE_SIZE/2)) {\n          speedCrates.splice(i, 1);\n          dotSpeedBoostUntil = Date.now() + SPEED_BOOST_DURATION;\n          dotColor = 'skyblue';\n          continue;\n        }\n        // Check chaser collisions\n        for (let chaser of chasers) {\n          if (distanceBetween(chaser.x, chaser.y, crate.x, crate.y) < (chaser.size/2 + CRATE_SIZE/2)) {\n            speedCrates.splice(i, 1);\n            chaserSpeedIncrease += 0.1;\n            break;\n          }\n        }\n      }\n\n      // Update chaser speeds\n      for (let chaser of chasers) {\n        chaser.speed = Math.min(1.4, CHASER_SPEED * (120 / chaser.size) + chaserSpeedIncrease);\n      }\n    }\n  \n    function wrapAround(type) {\n      if (type === \"dot\") {\n        if (dotX < 0) dotX = canvas.width;\n        else if (dotX > canvas.width) dotX = 0;\n        if (dotY < 0) dotY = canvas.height;\n        else if (dotY > canvas.height) dotY = 0;\n      }\n    }\n  \n    function wrapAroundChaser(chaser) {\n      if (chaser.x < 0) chaser.x = canvas.width;\n      else if (chaser.x > canvas.width) chaser.x = 0;\n      if (chaser.y < 0) chaser.y = canvas.height;\n      else if (chaser.y > canvas.height) chaser.y = 0;\n    }\n  \n    function checkCollision() {\n      const dotRadius = dotSize / 2;\n      const dotLeft = dotX - dotRadius;\n      const dotRight = dotX + dotRadius;\n      const dotTop = dotY - dotRadius;\n      const dotBottom = dotY + dotRadius;\n  \n      for (let chaser of chasers) {\n        const chaserLeft = chaser.x - chaser.size / 2;\n        const chaserRight = chaser.x + chaser.size / 2;\n        const chaserTop = chaser.y - chaser.size / 2;\n        const chaserBottom = chaser.y + chaser.size / 2;\n  \n        if (\n          dotRight > chaserLeft &&\n          dotLeft < chaserRight &&\n          dotBottom > chaserTop &&\n          dotTop < chaserBottom\n        ) {\n          return true;\n        }\n      }\n      return false;\n    }\n  \n    function drawKey(x, y, size) {\n      ctx.fillStyle = 'gold';\n      const headRadius = size / 3;\n      ctx.beginPath();\n      ctx.arc(x, y, headRadius, 0, Math.PI * 2);\n      ctx.fill();\n      \n      const shaftWidth = size / 4;\n      const shaftLength = size;\n      ctx.fillRect(x, y - shaftWidth / 2, shaftLength, shaftWidth);\n      \n      const toothSize = shaftWidth;\n      ctx.fillRect(x + shaftLength, y - toothSize / 2, toothSize, toothSize);\n    }\n  \n    function renderGame() {\n      ctx.fillStyle = 'black';\n      ctx.fillRect(0, 0, canvas.width, canvas.height);\n  \n      // Draw mud patches first (under everything else)\n      for (let mud of mudPatches) {\n        // Dark brown base\n        ctx.fillStyle = '#3d2817';\n        ctx.beginPath();\n        ctx.arc(mud.x, mud.y, mud.size / 2, 0, Math.PI * 2);\n        ctx.fill();\n\n        // Add stored texture spots\n        ctx.fillStyle = '#4a3423';\n        for (let spot of mud.spots) {\n          let spotX = mud.x + Math.cos(spot.angle) * spot.dist;\n          let spotY = mud.y + Math.sin(spot.angle) * spot.dist;\n          ctx.beginPath();\n          ctx.arc(spotX, spotY, spot.size / 2, 0, Math.PI * 2);\n          ctx.fill();\n        }\n\n        // Add stored shine spots\n        ctx.fillStyle = '#5c412c';\n        for (let shine of mud.shineSpots) {\n          let spotX = mud.x + Math.cos(shine.angle) * shine.dist;\n          let spotY = mud.y + Math.sin(shine.angle) * shine.dist;\n          ctx.beginPath();\n          ctx.arc(spotX, spotY, mud.size / 8, 0, Math.PI * 2);\n          ctx.fill();\n        }\n      }\n\n      // Draw the dot with current color\n      ctx.fillStyle = dotColor;\n      ctx.beginPath();\n      ctx.arc(dotX, dotY, dotSize / 2, 0, Math.PI * 2);\n      ctx.fill();\n\n      // Draw chasers\n      ctx.fillStyle = 'green';\n      for (let chaser of chasers) {\n        ctx.fillRect(\n          chaser.x - chaser.size / 2,\n          chaser.y - chaser.size / 2,\n          chaser.size,\n          chaser.size\n        );\n      }\n\n      // Draw collectible keys on top\n      for (let item of collectibles) {\n        drawKey(item.x, item.y, item.size);\n      }\n\n      // Draw hearts for lives in top-left\n      ctx.textAlign = 'left';\n      for (let i = 0; i < 3; i++) {\n        let heartX = 20 + i * 35;\n        let heartY = 40;\n        if (i < lives) {\n          ctx.fillStyle = 'yellow';\n          ctx.fillText(\"♥\", heartX, heartY);\n        } else {\n          ctx.strokeStyle = 'yellow';\n          ctx.strokeText(\"♥\", heartX, heartY);\n        }\n      }\n\n      // Draw score\n      ctx.fillStyle = 'white';\n      ctx.font = '30px monospace';\n      ctx.textAlign = 'right';\n      ctx.fillText(`Score: ${score}`, canvas.width - 20, 40);\n\n      // Draw speed crates with lightning bolt\n      for (let crate of speedCrates) {\n        // Wooden crate appearance\n        ctx.fillStyle = '#8B4513';\n        ctx.fillRect(crate.x - CRATE_SIZE/2, crate.y - CRATE_SIZE/2, CRATE_SIZE, CRATE_SIZE);\n        \n        // Add wood grain effect\n        ctx.strokeStyle = '#654321';\n        ctx.lineWidth = 2;\n        for (let i = -2; i <= 2; i++) {\n          ctx.beginPath();\n          ctx.moveTo(crate.x - CRATE_SIZE/2, crate.y + i * 5);\n          ctx.lineTo(crate.x + CRATE_SIZE/2, crate.y + i * 5);\n          ctx.stroke();\n        }\n        // Vertical edges\n        ctx.beginPath();\n        ctx.moveTo(crate.x - CRATE_SIZE/2, crate.y - CRATE_SIZE/2);\n        ctx.lineTo(crate.x - CRATE_SIZE/2, crate.y + CRATE_SIZE/2);\n        ctx.moveTo(crate.x + CRATE_SIZE/2, crate.y - CRATE_SIZE/2);\n        ctx.lineTo(crate.x + CRATE_SIZE/2, crate.y + CRATE_SIZE/2);\n        ctx.stroke();\n\n        // Add blue lightning bolt\n        ctx.strokeStyle = '#00BFFF'; // Deep sky blue\n        ctx.lineWidth = 3;\n        ctx.beginPath();\n        // Start at top\n        ctx.moveTo(crate.x, crate.y - CRATE_SIZE/3);\n        // Zigzag down\n        ctx.lineTo(crate.x + CRATE_SIZE/4, crate.y);\n        ctx.lineTo(crate.x - CRATE_SIZE/4, crate.y);\n        ctx.lineTo(crate.x, crate.y + CRATE_SIZE/3);\n        ctx.stroke();\n        \n        // Add glow effect\n        ctx.strokeStyle = 'rgba(0, 191, 255, 0.3)';\n        ctx.lineWidth = 6;\n        ctx.stroke();\n      }\n    }\n  \n    function renderGameOver() {\n      ctx.fillStyle = 'black';\n      ctx.fillRect(0, 0, canvas.width, canvas.height);\n  \n      ctx.fillStyle = 'red';\n      ctx.font = '80px monospace';\n      ctx.textAlign = 'center';\n      ctx.textBaseline = 'middle';\n      ctx.fillText(\"GAME OVER\", canvas.width / 2, canvas.height / 2);\n    }\n  \n    function renderStartScreen() {\n      ctx.fillStyle = '#000033';\n      ctx.fillRect(0, 0, canvas.width, canvas.height);\n  \n      for (let star of stars) {\n        ctx.fillStyle = 'yellow';\n        ctx.beginPath();\n        ctx.arc(star.x, star.y, star.radius, 0, Math.PI * 2);\n        ctx.fill();\n      }\n  \n      ctx.fillStyle = 'white';\n      ctx.font = '50px monospace';\n      ctx.textAlign = 'center';\n      ctx.fillText(\"PRESS SPACE TO START\", canvas.width / 2, canvas.height / 2);\n    }\n  \n    initializeStars();\n    gameLoop();\n\n    // Update mud spawning with occasional huge patches\n    setInterval(() => {\n      if (gameState === \"playing\") {\n        let numToSpawn = Math.floor(Math.random() * 5) + 1;\n        for (let i = 0; i < numToSpawn; i++) {\n          // 10% chance for huge mud patch\n          let mudSize = Math.random() < 0.1 ? \n            canvas.width / 4 : // Huge mud (quarter screen)\n            Math.random() * 30 + 30;  // Normal mud\n          \n          let spots = [];\n          for (let j = 0; j < 5; j++) {\n            spots.push({\n              angle: Math.random() * Math.PI * 2,\n              dist: Math.random() * (mudSize / 4),\n              size: mudSize / 3 + Math.random() * (mudSize / 4)\n            });\n          }\n          let shineSpots = [];\n          for (let j = 0; j < 3; j++) {\n            shineSpots.push({\n              angle: Math.random() * Math.PI * 2,\n              dist: Math.random() * (mudSize / 5)\n            });\n          }\n          mudPatches.push({\n            x: Math.random() * canvas.width,\n            y: Math.random() * canvas.height,\n            size: mudSize,\n            spots: spots,\n            shineSpots: shineSpots\n          });\n        }\n      }\n    }, 30000);\n\n    // Fix key spawning - remove old intervals and add new ones\n    const keySpawnInterval = setInterval(() => {\n      if (gameState === \"playing\") {\n        let numToSpawn = Math.floor(Math.random() * 5) + 1;\n        for (let i = 0; i < numToSpawn; i++) {\n          collectibles.push({\n            x: Math.random() * canvas.width,\n            y: Math.random() * canvas.height,\n            size: 15\n          });\n        }\n      }\n    }, 30000);\n\n    const keyRemovalInterval = setInterval(() => {\n      if (gameState === \"playing\" && collectibles.length > 0) {\n        let numToRemove = Math.floor(Math.random() * 11);\n        for (let i = 0; i < numToRemove; i++) {\n          if (collectibles.length > 0) {\n            const index = Math.floor(Math.random() * collectibles.length);\n            collectibles.splice(index, 1);\n          }\n        }\n      }\n    }, 60000);\n\n    // Spawn speed crates every 60 seconds (1-2 crates)\n    setInterval(() => {\n      if (gameState === \"playing\") {\n        let numToSpawn = Math.floor(Math.random() * 2) + 1;\n        for (let i = 0; i < numToSpawn; i++) {\n          speedCrates.push({\n            x: Math.random() * canvas.width,\n            y: Math.random() * canvas.height\n          });\n        }\n      }\n    }, 60000);\n\n    // Remove speed crates every 40 seconds (0-1 crates)\n    setInterval(() => {\n      if (gameState === \"playing\" && speedCrates.length > 0) {\n        if (Math.random() < 0.5) { // 50% chance to remove one\n          const index = Math.floor(Math.random() * speedCrates.length);\n          speedCrates.splice(index, 1);\n        }\n      }\n    }, 40000);\n\n    // Add helper function if not already present\n    function distanceBetween(x1, y1, x2, y2) {\n      const dx = x1 - x2;\n      const dy = y1 - y2;\n      return Math.sqrt(dx * dx + dy * dy);\n    }\n})();\n  "],"names":[],"version":3,"file":"index.de158e3a.js.map","sourceRoot":"/__parcel_source_root/"}